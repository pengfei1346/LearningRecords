<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<body>

</body>

<script>
    // let a = {
    //     name: '1',
    //     age: 18
    // }
    // console.log(a.__proto__);
    // a.__proto__.type = "animal"
    // // a.prototype.getName = function () {
    // //     return a.name
    // // }
    //
    // for (const aKey in a) {
    //     console.log(aKey);
    // }

    //  prototype
    //  每个函数都有一个prototype属性，这个属性指向函数的原型对象
    //  --每一个javascript对象(除null外)创建的时候，就会与之关联另一个对象，
    //  --这个对象就是我们所说的原型，每一个对象都会从原型中“继承”属性
    // function Person(age) {
    //     this.age = age
    // }
    // Person.prototype.name = 'kavin'
    // let person1 = new Person()
    // let person2 = new Person()
    // console.log(person1);
    // console.log(person1.name) //kavin
    // console.log(person2.name)  //kavin

    //  __proto__
    //  这是每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。

    // function Person() {
    //
    // }
    // let person = new Person();
    // console.log(person.__proto__ === Person.prototype); // true

    /*
    *
    * 补充说明:
    * 绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，
    * 它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，
    * 可以理解成返回了 Object.getPrototypeOf(obj)。
    * */

    //  constructor
    //  每个原型都有一个constructor属性，指向该关联的构造函数。
    function Person() {

    }

    var person = new Person();

    console.log(person.__proto__ === Person.prototype) // true
    console.log(Person.prototype.constructor === Person) // true
    console.log(person.constructor === Person); // true
    //  当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：
    // 顺便学习一个ES5的方法,可以获得对象的原型
    console.log(Object.getPrototypeOf(person) === Person.prototype) // true



    //   简单的回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》
    // 原型链的尽头是null

    /*
    * 原型：
    * 任何函数都可以作为构造函数，只要被new了，就是一个构造函数，每个函数都有一个prototype属性，这个是生成函数时自动加上的，函数的这个prototype属性指向的就是函数的原型对象
    * 每个原型对象都有一个constructor构造器，这个属性指向的就是引用的那个构造函数，也就是声明这个原型对象的函数
    * 每个对象都有一个__proto__属性，这个属性指向的是这个的对象的构造函数的的原型对象，也就是说一个实例对象的原型是等于它的构造函数的原型对象
    *
    *
    * 原型链：从一个对象上获取某一个属性或者方法时，如果这个对象本身不具备这个属性或者方法，那就会从这个对象的构造函数的原型对象上去找，如果还没找到就会从构造函数的构造函数上去找，直到找到构造函数为Object时终止，因为Object.prototype.proto===null，这样形成的一个链条就叫原型链。
    * */

    // todo instanceof

</script>

</html>
