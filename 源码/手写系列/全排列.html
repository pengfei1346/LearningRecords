<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>

<script>
  // 全排列
  //  要求以数组的形式返回字符串参数的所有排列组合。
  //  字符串参数中的字符无重复且仅包含小写字母
  //   返回的排列组合数组不区分顺序
  /*
  * 示例 1：
    输入：nums = [1,1,2]
    输出： [[1,1,2], [1,2,1], [2,1,1]]
    示例 2：

    输入：nums = [1,2,3]
    输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
    提示：

    1 <= nums.length <= 8
    -10 <= nums[i] <= 10
  * */


  //    回溯
  function permuteUnique(nums) {
      // 保存结果数组，保存每个路径（排列）
      const result = [];
      // 调用回溯函数，传入参数
      backtracking(nums, nums.length, [], []);
      // 返回结果数组
      return result;

      // 定义回溯递归函数，传入数组，长度，节点是否被使用过的数组
      // used 用来标记节点是否被用过 path 用来存储路径，定义为一个栈
      function backtracking(nums, len, used, path) {
          // 递归出口
          // 如果到达叶子节点，将路径推入结果数组，并返回
          if (path.length === len) {
              result.push([...path]);
              return;
          }
          // 遍历候选字符
          for (let i = 0; i < len; i++) {
              // 使用过就下一轮循环
              if (!used[i]) {
                  // undefind和fasle都会进来
                  // 这里说明这个数还没有被使用，入栈path
                  path.push(nums[i]);
                  // 标记这个数被使用过了
                  used[i] = true;
                  // 开始进行递归
                  backtracking(nums, len, used, path);
                  // 回溯【状态重置】撤销之前的操作
                  path.pop();
                  used[i] = false;
              }
          }
      }

  }

  console.log(permuteUnique(["a", "b", "c"]));
</script>

</html>
