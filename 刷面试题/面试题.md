### 类型
0.1 + 0.2 !== 0.3
JS 类型有哪些？
大数相加、相乘算法题
修改对象得出结果笔试题
判断数据类型

JS 类型如何判断，有哪几种方式可用
instanceof 原理
手写 instanceof


>  伪数组转成真数组的方法（至少两种方法）

常见的伪数组
1.函数的内置对象arguments，它是所有实参组成的伪数组。
2.DOM对象组成的伪数组，通过document.querySelectorAll等获得的dom对象列表。
3.jQuery对象组成的伪数组，通过$('选择器')获取到的包含dom对象列表和jQuery方法的jQuery对象。

1、for循环 
2、 [...arg]
3、let arr = [].slice.call(divs)
4、Array.from // 浅拷贝

> 1.js的垃圾回收机制是什么原理（js）!!

标记清除法、引入计数

标记清除法:常用


标记内存中所有的变量
把在上下文(全局作用域, 脚本作用域)中声明的变量,以及在全局被引用的变量的标记删除掉, 剩下的所有带标记的变量就被视为要删除的变量, 垃圾回收执行时释放它们占用的内存
内存清理, 清除垃圾

引用计数：

引用计数是一种不常用的垃圾回收策略, 主要核心思路就是记录值被引用的次数, 一个值被赋给变量,引用次数+1, 这个变量在某个时刻重新赋了一个新值, 旧值的引用次数-1变为了0, 在下次垃圾回收程序进行时就会释放它的内存

#### 闭包

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念。
闭包有三个特性：
1.函数嵌套函数
2.函数内部可以引用外部的参数和变量
3.参数和变量不会被垃圾回收机制回收

* 
#### 1、new干了什么？
```js

```
#### 2、深拷贝怎么实现，什么场景下会使用？
#### 3、事件循环机制？
#### 4、url到页面的渲染过程？dom树是如何渲染的？
* 答案

  * DNS解析域名找到对应IP-----dns解析也存在缓存
  * 通过IP找到对应服务器进行三次握手建立tcp连接
  * 服务器接收到信息返回对应文件
  * 浏览器判断状态码开始处理
  * 判断是否是压缩文件
  * 解析html构建DOM树、CSSOM树、执行js文件
  * 生成 Render 树，GPU 绘制，合成图层，将内容显示在屏幕上

浏览器的简要渲染过程：
解析HTML-->构建DOM树(DOM Tree)
加载样式-->解析样式-->构建样式规则树(CSS Tree)
加载js-->执行js代码
把DOM树和样式规则树匹配构建渲染树(Render Tree)
计算元素进行布局 (Layout)
绘制 (Paiting)

图片记载和渲染的时机：
解析HTML【遇到标签加载图片】-->构建DOM树
加载样式-->解析样式 【遇到背景图片链接不加载】-->构建样式规则树
加载js-->执行js代码
把DOM树和样式规则树匹配构建渲染树【加载渲染树上的背景图片】
计算元素位置进行布局
绘制【开始渲染图片】

重排Reflow
定义：浏览器根据各种样式计算记过将各种DOM元素放到它该出现的位置，这个过程就是Reflow
触发条件：
增加、删除、修改DOM节点，绘导致Reflow或Repaint
移动DOM位置或者动画
修改CSS样式
Resize窗口或者滚动的时候
修改网页的默认字体时

重绘Repaint
定义：页面要呈现的内容统统画在屏幕上
触发：
DOM改动
CSS改动

* http缓存机制

强缓存和协商缓存

强缓存：
强缓存的状态码是200。
强缓存主要是采用响应头中的 Cache-Control 和 Expires 两个字段进行控制的。同时使用的时候 Cache-Control 的优先级会更高一点，需要注意no-cache不是不缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而no-store才表示不会被缓存，及不使用强制缓存，也不使用协商缓存。
Pragma：Pragma只有一个属性值，就是no-cache，效果和Cache-Ctrol中的no-cache一致，不使用强缓存，优先级最高。

协商缓存： ( Last-Modified 和 Etag )

1、强缓存和协商缓存同时存在，如果强缓存还在有效期内则直接使用缓存；如果强缓存不在有效期，协商缓存生效。
即：强缓存优先级 > 协商缓存优先级

2、强缓存的 expires 和 cache-control 同时存在时， cache-control 会覆盖 expires 的效果， expires 无论有没有过期，都无效。
即：cache-control 优先级 > expires 优先级。

3、协商缓存的 Etag 和 Last-Modified 同时存在时， Etag 会覆盖 Last-Modified的效果。
即：ETag 优先级 > Last-Modified 优先级。


#### 5、平时怎么使用ts
类型约束、联合类型、泛型、
#### 6、vue2和3的区别？key有什么作用=>虚拟dom和diff算法的实现？

object.defineproperty：
深度监听，需要递归到底，一次计算量大
无法监听新增属性/删除属性(所以需要使用 Vue.set 和 Vue.delete)
无法原生监听数组，需要特殊处理
无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实施响应。
只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历。Vue2.X里，是通过递归 + 遍历data对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历，显然如果能劫持一个完整的对象才是更好的选择。

proxy：直接监听整个对象，并返回一个新对象；  有多种劫持操作(13种)

vue2 对比vue3，
diff算法优化，vue2中作的是全量对比，vue3使用了静态标记，对于被标记的元素不参与更新，渲染一次之后不断复用。

#### 7、类的继承？
#### 8、AST是什么？webpack的概念？怎么手写一个loader。
#### 9、拖拽？
#### 10、for of原理？
迭代器、迭代器协议
#### EventLoop？

背景： js是单线程
单线程需要协调事件、用户交互、脚本、UI 渲染、网络请求，需要使用事件循环机制。

事件机制：
* 1、所有同步任务都在主线程上执行，形成一个 执行栈（Execution Context Stack）
* 2、主线程之外，还存在一个 任务队列（Task Queue）。只要异步任务有了运行结果，就在 任务队列 之中放置一个事件
* 3、一旦 执行栈 中的所有同步任务执行完毕，系统就会读取 任务队列，看看里面有哪些待执行事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
* 4、主线程不断重复上面的第三步

#### 请简述 webpack 中的 loaders 与 plugin 的区别 什么是 loaders？

loaders 是文件加载器，能够加载资源文件，并对 这些文件进行处理，例如，编译，压缩等，最终一起打包到指定文件 中。
什么是 plugin，在 webpack 运行的生命周期会有许多事件，plugin 可以监听这些事件 
区别：加载器是用来加载文件的，webpack 本身只能加载 js 文件(内 置 babel-loader)，加载其他文件就需要安装别的 loader，比如： css-loader file-loader 
Plugin 是扩展 webpack 功能的，通过 plugin ，webpack 可以实 现 loader 不能完成的复杂功能

#### 前端性能优化（必考）
    * 图片压缩处理
    * 懒加载
    * 骨架屏
    * cdn应用
    * 动态加载组件
    * 服务端渲染
    * 预渲染
    * 按需加载
    * 开启gzip

### 事件流

目标的捕获-到达目标-事件冒泡
dom0级别事件、dom2级别事件、dom3

* 

#### 1、
```js
/**
 * url = "www.baidu.com/"
 * options = {
 *     name: 123,
 *     age: [
 *         "11","22"
 *     ],
 *     h: "啊？啊"
 * }
 * 输出
 *
 * url = "www.baidu.com/?name=123&age=12&age=22&h=%E5%95%8A%EF%BC%9F%E5%95%8A"
 * */
```
#### 2、

```js
/*
*  id   parentId   name
 1    0          AA
 2    1          BB
 3    1          CC
 4    3          DD
 5    3          EE
 6    2          FF
 7    2          GG
 8    4          HH
 9    5          II
* 
interface TreeNode {
    id: number; // 节点 ID
    parentId: number; // 父节点 ID
    name: string； // 节点名称
}
请写一个函数 printTree(list: TreeNode[]): void 把输入的数据在控制台打印为一个有缩进的树形结构。上面的示例输出的结果如下：
AA
  BB
    FF
    GG
  CC
    DD
      HH
    EE
      II
* */
```

#### 3、
```js
const rule = {
        name: "String",
        age: "Number",
        hobby: "Array",
        father: {
            name: "String",
            age: "Number"
        },
        sister: {
            name: "String",
            father: {
                name: "String",
                age: "Number",
                hobby: "Array",
                marry: "Boolean"
            }
        }
    }

    const data = {
        name: "张三",
        age: 18,
        marry: undefined,
        hobby: ["游泳","打球"],
        father: {
            name: '88',
            age: null
        },
        sister: {
            name: '99',
            father: {
                name: '88',
                hobby: null,
                marry: false
            }
        }
    }
    /**
     * @desc 给定一个对象data，rule是对象的类型规则，找出所有不满足类型的字段
     * @return ["marry","father.age","sister.father.hobby"] 
     * */
    
    // 答案见源码-js-js_树形结构-1.html
```











